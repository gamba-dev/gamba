# AUTOGENERATED! DO NOT EDIT! File to edit: 21_measures.ipynb (unless otherwise specified).

__all__ = ['check_measure_data', 'duration', 'frequency', 'number_of_bets', 'mean_bets_per_day', 'total_wagered',
           'net_loss', 'intensity', 'frequency_raw', 'mean_bet_size', 'variability', 'trajectory', 'percent_loss',
           'calculate_labrie_measures', 'calculate_braverman_measures']

# Cell
def check_measure_data(player_bets, required_columns):
    "Compares the columns found in a dataframe of player bets to a supplied list of column names. If any of the required_column names are not found, an exception is raised reporting the error."

    for column in required_columns:
        if column not in player_bets.columns:
            exception_string = (
                "Column '" + column + "' missing from provided dataframe."
            )
            raise Exception(exception_string)

# Cell
def duration(player_bets):
    "The number of days between the first bet and the last."
    check_measure_data(player_bets, ["bet_time"])
    player_bets.sort_values("bet_time", inplace=True)
    player_bets.reset_index(drop=True, inplace=True)

    first_day = player_bets.iloc[0]["bet_time"]
    last_day = player_bets.iloc[len(player_bets) - 1]["bet_time"]
    # add one to make it interpret as 'days where betting has occurred'
    age_in_days = (last_day.date() - first_day.date()).days + 1
    return age_in_days

# Cell
def frequency(player_bets):
    "The percentage of days within the `duration` that included at least one bet. Note that this method returns the actual percentage value e.g. 75, **not** the raw number of days or values in the interval [0,1]."
    check_measure_data(player_bets, ["bet_time"])
    player_bets.sort_values("bet_time", inplace=True)
    player_bets.reset_index(drop=True, inplace=True)
    age_in_days = duration(player_bets)

    player_bets["bet_date"] = player_bets["bet_time"].dt.date
    first_day = player_bets.iloc[0]["bet_time"]

    betting_days = 0
    for day in range(age_in_days):
        current_date = (first_day + datetime.timedelta(days=day)).date()
        bets_today = player_bets.iloc[player_bets["bet_date"].values == current_date]
        if len(bets_today) != 0:
            betting_days += 1

    frequency_percentage = (betting_days / age_in_days) * 100
    return frequency_percentage

# Cell
def number_of_bets(player_bets, daily=False):
    "The total number of bets made."

    if daily:
        check_measure_data(player_bets, ["bet_count"])
        return player_bets["bet_count"].sum()

    return len(player_bets)

# Cell
def mean_bets_per_day(player_bets, daily=False):
    "The average (mean) number of bets made on days where betting took place."

    if daily:

        age_in_days = duration(player_bets)
        frequency_percentage = frequency(player_bets)

        betting_days = (frequency_percentage / 100) * age_in_days

        average_bets_per_day = (
            number_of_bets(player_bets, daily=True) / betting_days  # taken from LaBrie 2008
        )
        return average_bets_per_day

    # otherwise compute regular mean bets per day measure
    age_in_days = duration(player_bets)
    frequency_percentage = frequency(player_bets)

    betting_days = (frequency_percentage / 100) * age_in_days

    average_bets_per_day = len(player_bets) / betting_days  # taken from LaBrie 2008
    return average_bets_per_day

# Cell
def total_wagered(player_bets):
    "The total amount wagered (sum of bet sizes)."
    check_measure_data(player_bets, ["bet_size"])
    return player_bets["bet_size"].sum()

# Cell
def net_loss(player_bets):
    "The net amount lost (sum of bet sizes minus sum of payout sizes)."
    check_measure_data(player_bets, ["bet_size", "payout_size"])
    net_loss_value = player_bets["bet_size"].sum() - player_bets["payout_size"].sum()
    return net_loss_value

# Cell
def intensity(player_bets):
    "Mean number of bets per active betting day in first month, if data set contains daily aggregate data."

    first_day = player_bets.iloc[0]["bet_time"]
    one_month_later = first_day + datetime.timedelta(days=+30)
    first_month_bets = player_bets[player_bets["bet_time"] <= one_month_later]
    result = first_month_bets["bet_count"].mean()
    return result

# Cell
def frequency_raw(player_bets):
    "Number of active betting days in first month, if data set contains daily aggregate data."

    first_day = player_bets.iloc[0]["bet_time"]
    one_month_later = first_day + datetime.timedelta(days=+30)
    first_month_bets = player_bets[player_bets["bet_time"] <= one_month_later]

    return len(first_month_bets)

# Cell
def mean_bet_size(player_bets, daily=False):
    "The average (mean) size of bets."
    if daily:
        check_measure_data(player_bets, ["bet_size"])
        average_bet_size = player_bets["bet_size"].sum() / number_of_bets(player_bets, daily=True)
        return average_bet_size

    check_measure_data(player_bets, ["bet_size"])
    average_bet_size = player_bets["bet_size"].sum() / len(player_bets)
    return average_bet_size

# Cell
def variability(player_bets, daily=False):
    "Standard deviation of stake size in first month, if data set contains daily aggregate data."

    if daily:
        first_day = player_bets.iloc[0]["bet_time"]
        one_month_later = first_day + datetime.timedelta(days=+30)
        first_month_bets = player_bets[player_bets["bet_time"] <= one_month_later]

        return first_month_bets["bet_size"].std()

# Cell
from sklearn.linear_model import LinearRegression
def trajectory(player_bets, daily=False, plot=False):
    "Gradient of a linear regression fitted to the sequence of daily aggredated bet sizes."

    if daily:
        first_day = player_bets.iloc[0]["bet_time"]
        one_month_later = first_day + datetime.timedelta(days=+30)
        first_month_bets = player_bets[player_bets["bet_time"] <= one_month_later]

        # first_month_bets['mean_bet_size'] = first_month_bets['bet_size'] / first_month_bets['bet_count']

        x = np.array(range(len(first_month_bets))).reshape((-1, 1)) + 1
        y = first_month_bets["bet_size"].values

        model = LinearRegression().fit(x, y)
        r_sq = model.score(x, y)

        model_x = x
        model_y = model.coef_ * x + model.intercept_

        if plot:
            plt.figure()
            plt.scatter(x, y)
            plt.plot(model_x, model_y, color="r")
            plt.show()

        trajectory = model.coef_[0]
        return model.coef_[0]

# Cell
def percent_loss(player_bets):
    "The `net_loss` as a percentage of `total_wagered`."

    net_loss_value = net_loss(player_bets)
    total_wagered_value = total_wagered(player_bets)
    percent_loss_value = (net_loss_value / total_wagered_value) * 100
    return percent_loss_value

# Cell
from tqdm import tqdm
import datetime, pandas as pd
def calculate_labrie_measures(all_player_bets, savedir="", filename="gamba_labrie_measures.csv", loud=False, daily=True,):
    "Calculates the set of measures described in LaBrie et al's work in 2008 on casino gamblers. These measures include the durations, frequencies, number of bets, bets per day, value per bet (eth), total amount wagered, net loss, and percent loss for each player. As this method sits in the studies module, it accepts a list of dataframes representing each player's bets as input. By default, this method saves the resulting dataframe of each player's measures to 'gamba_labrie_measures.csv'. Be advised: this method can take some time for large numbers of players, the 'loud' parameter can be set to True to print out updates every 200 players."

    pd.options.mode.chained_assignment = None # supress setwithcopy warnings

    player_id = []
    all_duration = []
    all_frequency = []
    all_number_of_bets = []
    all_average_bets_per_day = []
    all_average_bet_size = []
    all_total_wagered = []
    all_net_loss = []
    all_percent_loss = []

    unique_players = list(set(all_player_bets["player_id"]))

    for i in tqdm(range(len(unique_players))):
        player_bets = all_player_bets[all_player_bets["player_id"] == unique_players[i]]
        player_id.append(player_bets.iloc[0]["player_id"])
        all_duration.append(duration(player_bets))
        all_frequency.append(frequency(player_bets))
        if daily:
            all_number_of_bets.append(number_of_bets(player_bets, daily=True))
            all_average_bets_per_day.append(mean_bets_per_day(player_bets, daily=True))
            all_average_bet_size.append(mean_bet_size(player_bets, daily=True))
        else:
            all_number_of_bets.append(number_of_bets(player_bets))
            all_average_bets_per_day.append(average_bets_per_day(player_bets))
            all_average_bet_size.append(average_bet_size(player_bets))
        all_total_wagered.append(total_wagered(player_bets))
        all_net_loss.append(net_loss(player_bets))
        all_percent_loss.append(percent_loss(player_bets))

    labrie_dict = {
        "player_id": player_id,
        "duration": all_duration,
        "frequency": all_frequency,
        "num_bets": all_number_of_bets,
        "average_bets_per_day": all_average_bets_per_day,
        "average_bet_size": all_average_bet_size,
        "total_wagered": all_total_wagered,
        "net_loss": all_net_loss,
        "percent_loss": all_percent_loss,
    }

    labrie_measures = pd.DataFrame.from_dict(labrie_dict)
    labrie_measures.to_csv(savedir + filename, index=False)

    if loud:
        print("LaBrie measures saved")

    return labrie_measures

# Cell
def calculate_braverman_measures(all_player_bets, savedir="", loud=False):
    "Calculates the set of measures described in Braverman and Shaffer's work in 2010 on high risk internet gamblers. These measures include the frequency, intensity, variability, and trajectories of each player. As this method sits in the studies module, it accepts a list of dataframes representing each player's bets as input. By default, this method saves the resulting dataframe of each player's measures to 'gamba_braverman_measures.csv'."

    player_id = []

    intensity = []
    variability = []
    frequency = []
    trajectory = []

    sum_of_stakes = []
    total_num_bets = []
    average_bet_size = []
    duration = []
    net_loss = []

    unique_players = list(set(all_player_bets["player_id"]))

    for i in tqdm(range(len(unique_players))):
        player_bets = all_player_bets[all_player_bets["player_id"] == unique_players[i]]

        player_id.append(player_bets.iloc[0]["player_id"])
        intensity.append(intensity_daily(player_bets))
        frequency.append(frequency_daily(player_bets))
        variability.append(variability_daily(player_bets))
        trajectory.append(trajectory_daily(player_bets))

        sum_of_stakes.append(player_bets["bet_size"].sum())
        total_num_bets.append(player_bets["bet_count"].sum())
        average_bet_size.append(
            player_bets["bet_size"].sum() / player_bets["bet_count"].sum()
        )
        duration.append(duration(player_bets))
        net_loss.append(net_loss(player_bets))

    braverman_dict = {
        "player_id": player_id,
        "intensity": intensity,
        "frequency": frequency,
        "variability": variability,
        "trajectory": trajectory,
        "sum_of_stakes": sum_of_stakes,
        "total_num_bets": total_num_bets,
        "average_bet_size": average_bet_size,
        "duration": duration,
        "net_loss": net_loss,
    }

    braverman_measures = pd.DataFrame.from_dict(braverman_dict)
    braverman_measures.to_csv(savedir + "gamba_braverman_measures.csv", index=False)

    return braverman_measures